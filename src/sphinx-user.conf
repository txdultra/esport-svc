source member
{
	type			= mysql

	sql_host		= 127.0.0.1
	sql_user		= root
	sql_pass		= neotv
	sql_db			= m_mobile
	sql_port		= 3306

	sql_query		= SELECT m.uid as id,m.uid,m.nick_name,UNIX_TIMESTAMP(m.create_time) AS create_time,\
				  s.longitude,s.latitude,s.vods,s.fans,s.friends,s.notes,s.count_1,s.count_2,s.count_3,s.count_4,s.count_5,\
				  m.certified \
				  from common_member m \
				  join common_member_states s on s.uid=m.uid \
				  where m.uid<=(SELECT max_doc_id FROM sph_user_counter WHERE counter_id=1) \
                  and m.uid>=$start AND m.uid<=$end
	
	sql_field_string	= nick_name
	sql_attr_uint		= uid
	sql_attr_timestamp	= create_time
	sql_attr_uint		= certified
	sql_attr_float		= longitude
	sql_attr_float		= latitude
	sql_attr_uint		= vods
	sql_attr_uint		= fans
	sql_attr_uint		= friends
	sql_attr_uint		= notes
	sql_attr_uint		= count_1
	sql_attr_uint		= count_2
	sql_attr_uint		= count_3
	sql_attr_uint		= count_4
	sql_attr_uint		= count_5

	#sql_query_info		= SELECT * FROM common_member WHERE uid=$id
	sql_query_pre		= SET NAMES utf8
	sql_query_pre		= set SESSION wait_timeout = 60
	sql_query_pre		= set SESSION interactive_timeout=60
	
	#sql_query_pre       = SET SESSION query_cache_type=OFF
	#创建一个sph_counter用于增量索引
    sql_query_pre        = CREATE TABLE IF NOT EXISTS sph_user_counter(counter_id INTEGER PRIMARY KEY NOT NULL,max_doc_id INTEGER NOT NULL)
    #取数据之前将表的最大id记录到sph_counter表中
    sql_query_pre        = REPLACE INTO sph_user_counter SELECT 1, MAX(uid) FROM common_member
	#分区查询设置
    sql_query_range      = SELECT MIN(uid),MAX(uid) FROM common_member
	#分区查询的步长
    sql_range_step       = 1000
	#设置分区查询的时间间隔
    sql_ranged_throttle  = 0
}

#定义一个增量的源
source member_delta : member
{
    sql_query_pre       = set names utf8
	
    #增量源只查询上次主索引生成后新增加的数据
	#如果新增加的uid比主索引建立时的uid还小那么会漏掉
    sql_query           = SELECT m.uid as id,m.uid,m.nick_name,UNIX_TIMESTAMP(m.create_time) AS create_time,\
				  s.longitude,s.latitude,s.vods,s.fans,s.friends,s.notes,s.count_1,s.count_2,s.count_3,s.count_4,s.count_5,\
				  m.certified \
				  from common_member m \
				  join common_member_states s on s.uid=m.uid \
				  where m.uid>(SELECT max_doc_id FROM sph_user_counter WHERE counter_id=1) \
                  and m.uid>=$start AND m.uid<=$end
    sql_query_range     = SELECT MIN(uid),MAX(uid) FROM common_member where \
                                       uid>(SELECT max_doc_id FROM sph_user_counter WHERE counter_id=1)
}


index member_idx
{
	source            = member             #对应的source名称
    path              = /var/sphinx/member_data #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
    docinfo           = extern
    mlock             = 0
    morphology        = none
    min_word_len      = 1
    html_strip        = 0

    #中文分词配置，详情请查看：http://www.coreseek.cn/products-install/coreseek_mmseg/
    charset_dictpath  = /usr/local/mmseg/etc/ #BSD、Linux环境下设置，/符号结尾
    charset_type      = zh_cn.utf-8
}

#定义增量索引
index member_delta_idx : member_idx
{
    source   = member_delta
    path     = /var/sphinx/member_data_delta
}

indexer
{
	mem_limit		= 32M
}


searchd
{
	listen			= 9313
	read_timeout        = 5
	max_children        = 0
	max_matches            = 1000
	seamless_rotate        = 1
	preopen_indexes        = 0
	unlink_old            = 1
	pid_file = /var/sphinx/log/searchd_member.pid  #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	log = /var/sphinx/log/searchd_member.log        #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	query_log = /var/sphinx/log/query_member.log #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	binlog_path =                                #关闭binlog日志
	binlog_max_log_size = 32M
	#最大允许的包大小
    max_packet_size    = 32M
	#最大允许的过滤器数
    max_filters        = 512
	#每个过滤器最大允许的值的个数
    max_filter_values  = 4096
}
