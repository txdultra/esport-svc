#
# Minimal Sphinx configuration sample (clean, simple, functional)
#

source vods
{
	type			= mysql

	sql_host		= 127.0.0.1
	sql_user		= root
	sql_pass		= neotv
	sql_db			= m_mobile
	sql_port		= 3306

	sql_query		= SELECT vv.id,vv.id as video_id, vv.title, vv.uid, UNIX_TIMESTAMP(vv.post_time) AS post_time,UNIX_TIMESTAMP(vv.add_time) as add_time,vv.seconds,vv.gid, \
					vc.views,vc.comments,vc.favorites,vc.dings,vc.cais,vc.downloads, \
					vc.ex1,vc.ex2,vc.ex3,vc.ex4,vc.ex5 \
					FROM vod_videos vv join vod_counts vc on vv.id=vc.vid where vv.no_idx=0 \
					and vv.id<=(SELECT max_doc_id FROM sph_vod_counter WHERE counter_id=1) \
                    and vv.id>=$start AND vv.id<=$end
	
	sql_field_string	= title
	sql_attr_uint		= video_id
	sql_attr_uint		= uid
	sql_attr_uint		= gid
	sql_attr_uint		= views
	sql_attr_uint		= comments
	sql_attr_uint		= favorites
	sql_attr_uint		= dings
	sql_attr_uint		= cais
	sql_attr_uint		= downloads
	sql_attr_uint		= ex1
	sql_attr_uint		= ex2
	sql_attr_uint		= ex3
	sql_attr_uint		= ex4
	sql_attr_uint		= ex5
	sql_attr_timestamp	= post_time
	sql_attr_timestamp	= add_time

	#sql_query_info		= SELECT * FROM vod_videos WHERE id=$id
	sql_query_pre		= SET NAMES utf8
	sql_query_pre		= set SESSION wait_timeout = 60
	sql_query_pre		= set SESSION interactive_timeout=60
	#sql_query_pre       = SET SESSION query_cache_type=OFF
	#创建一个sph_counter用于增量索引
    sql_query_pre        = CREATE TABLE IF NOT EXISTS sph_vod_counter(counter_id INTEGER PRIMARY KEY NOT NULL,max_doc_id INTEGER NOT NULL)
    #取数据之前将表的最大id记录到sph_counter表中
    sql_query_pre        = REPLACE INTO sph_vod_counter SELECT 1, MAX(id) FROM vod_videos
	#分区查询设置
    sql_query_range      = SELECT MIN(id),MAX(id) FROM vod_videos
	#分区查询的步长
    sql_range_step       = 1000
	#设置分区查询的时间间隔
    sql_ranged_throttle  = 0
}

#定义一个增量的源
source vods_delta : vods
{
    sql_query_pre       = set names utf8
	
    #增量源只查询上次主索引生成后新增加的数据
	#如果新增加的uid比主索引建立时的uid还小那么会漏掉
    sql_query           = SELECT vv.id,vv.id as video_id, vv.title, vv.uid, UNIX_TIMESTAMP(vv.post_time) AS post_time,UNIX_TIMESTAMP(vv.add_time) as add_time,vv.seconds,vv.gid, \
					vc.views,vc.comments,vc.favorites,vc.dings,vc.cais,vc.downloads, \
					vc.ex1,vc.ex2,vc.ex3,vc.ex4,vc.ex5 \
					FROM vod_videos vv join vod_counts vc on vv.id=vc.vid where vv.no_idx=0 \
					and vv.id>(SELECT max_doc_id FROM sph_vod_counter WHERE counter_id=1) \
                    and vv.id>=$start AND vv.id<=$end
    sql_query_range     = SELECT MIN(id),MAX(id) FROM vod_videos where \
                                       id>(SELECT max_doc_id FROM sph_vod_counter WHERE counter_id=1)
}

index vods_idx
{
	source            = vods             #对应的source名称
    path            = /var/sphinx/vods_data #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
    docinfo            = extern
    mlock            = 0
    morphology        = none
    min_word_len        = 1
    html_strip                = 0

    #中文分词配置，详情请查看：http://www.coreseek.cn/products-install/coreseek_mmseg/
    charset_dictpath = /usr/local/mmseg/etc/ #BSD、Linux环境下设置，/符号结尾
    charset_type        = zh_cn.utf-8
}

#定义增量索引
index vods_delta_idx : vods_idx
{
    source   = vods_delta
    path     = /var/sphinx/vods_data_delta
}

indexer
{
	mem_limit		= 32M
}


searchd
{
	listen			= 9312
	read_timeout        = 5
	max_children        = 0
	max_matches            = 1000
	seamless_rotate        = 1
	preopen_indexes        = 0
	unlink_old            = 1
	pid_file = /var/sphinx/log/searchd_vods.pid  #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	log = /var/sphinx/log/searchd_vods.log        #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	query_log = /var/sphinx/log/query_vods.log #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
	binlog_path =                                #关闭binlog日志
	binlog_max_log_size = 32M
}
