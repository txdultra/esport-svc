// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package proxy

import (
	"bytes"
	"fmt"

	"github.com/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type UserTaskService interface {
	// Parameters:
	//  - Group
	CreateGroup(group *TaskGroup) (r *ActionResult_, err error)
	// Parameters:
	//  - Group
	UpdateGroup(group *TaskGroup) (r *ActionResult_, err error)
	// Parameters:
	//  - GroupId
	DeleteGroup(groupId int64) (r *ActionResult_, err error)
	// Parameters:
	//  - GroupId
	GetGroup(groupId int64) (r *TaskGroup, err error)
	GetGroups() (r []*TaskGroup, err error)
	// Parameters:
	//  - Task
	CreateTask(task *Task) (r *ActionResult_, err error)
	// Parameters:
	//  - Task
	UpdateTask(task *Task) (r *ActionResult_, err error)
	// Parameters:
	//  - TaskId
	//  - GroupId
	DeleteTask(taskId int64, groupId int64) (r *ActionResult_, err error)
	// Parameters:
	//  - TaskId
	GetTask(taskId int64) (r *Task, err error)
	// Parameters:
	//  - GroupId
	GetTasks(groupId int64) (r []*Task, err error)
	GetEventNames() (r []*TaskEventName, err error)
	GetTaskTimers() (r []*TaskTimer, err error)
	// Parameters:
	//  - Uid
	//  - TaskId
	IsMissionPassed(uid int64, taskId int64) (r bool, err error)
	// Parameters:
	//  - Uid
	GetMissions(uid int64) (r []*MissionGroup, err error)
	// Parameters:
	//  - Uid
	//  - Event
	//  - N
	EventHandler(uid int64, event string, n int32) (r *EventResult_, err error)
}

type UserTaskServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewUserTaskServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserTaskServiceClient {
	return &UserTaskServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewUserTaskServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserTaskServiceClient {
	return &UserTaskServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - Group
func (p *UserTaskServiceClient) CreateGroup(group *TaskGroup) (r *ActionResult_, err error) {
	if err = p.sendCreateGroup(group); err != nil {
		return
	}
	return p.recvCreateGroup()
}

func (p *UserTaskServiceClient) sendCreateGroup(group *TaskGroup) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("CreateGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CreateGroupArgs{
		Group: group,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvCreateGroup() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error4 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error5 error
		error5, err = error4.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error5
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "CreateGroup failed: out of sequence response")
		return
	}
	result := CreateGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Group
func (p *UserTaskServiceClient) UpdateGroup(group *TaskGroup) (r *ActionResult_, err error) {
	if err = p.sendUpdateGroup(group); err != nil {
		return
	}
	return p.recvUpdateGroup()
}

func (p *UserTaskServiceClient) sendUpdateGroup(group *TaskGroup) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("UpdateGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UpdateGroupArgs{
		Group: group,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvUpdateGroup() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error6 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error7 error
		error7, err = error6.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error7
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "UpdateGroup failed: out of sequence response")
		return
	}
	result := UpdateGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - GroupId
func (p *UserTaskServiceClient) DeleteGroup(groupId int64) (r *ActionResult_, err error) {
	if err = p.sendDeleteGroup(groupId); err != nil {
		return
	}
	return p.recvDeleteGroup()
}

func (p *UserTaskServiceClient) sendDeleteGroup(groupId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("DeleteGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteGroupArgs{
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvDeleteGroup() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error9 error
		error9, err = error8.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error9
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "DeleteGroup failed: out of sequence response")
		return
	}
	result := DeleteGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - GroupId
func (p *UserTaskServiceClient) GetGroup(groupId int64) (r *TaskGroup, err error) {
	if err = p.sendGetGroup(groupId); err != nil {
		return
	}
	return p.recvGetGroup()
}

func (p *UserTaskServiceClient) sendGetGroup(groupId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetGroup", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupArgs{
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetGroup() (value *TaskGroup, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error11 error
		error11, err = error10.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error11
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetGroup failed: out of sequence response")
		return
	}
	result := GetGroupResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

func (p *UserTaskServiceClient) GetGroups() (r []*TaskGroup, err error) {
	if err = p.sendGetGroups(); err != nil {
		return
	}
	return p.recvGetGroups()
}

func (p *UserTaskServiceClient) sendGetGroups() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetGroups", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetGroupsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetGroups() (value []*TaskGroup, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error12 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error13 error
		error13, err = error12.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error13
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetGroups failed: out of sequence response")
		return
	}
	result := GetGroupsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Task
func (p *UserTaskServiceClient) CreateTask(task *Task) (r *ActionResult_, err error) {
	if err = p.sendCreateTask(task); err != nil {
		return
	}
	return p.recvCreateTask()
}

func (p *UserTaskServiceClient) sendCreateTask(task *Task) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("CreateTask", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CreateTaskArgs{
		Task: task,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvCreateTask() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error14 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error15 error
		error15, err = error14.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error15
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "CreateTask failed: out of sequence response")
		return
	}
	result := CreateTaskResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Task
func (p *UserTaskServiceClient) UpdateTask(task *Task) (r *ActionResult_, err error) {
	if err = p.sendUpdateTask(task); err != nil {
		return
	}
	return p.recvUpdateTask()
}

func (p *UserTaskServiceClient) sendUpdateTask(task *Task) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("UpdateTask", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UpdateTaskArgs{
		Task: task,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvUpdateTask() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error16 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error17 error
		error17, err = error16.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error17
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "UpdateTask failed: out of sequence response")
		return
	}
	result := UpdateTaskResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - TaskId
//  - GroupId
func (p *UserTaskServiceClient) DeleteTask(taskId int64, groupId int64) (r *ActionResult_, err error) {
	if err = p.sendDeleteTask(taskId, groupId); err != nil {
		return
	}
	return p.recvDeleteTask()
}

func (p *UserTaskServiceClient) sendDeleteTask(taskId int64, groupId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("DeleteTask", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteTaskArgs{
		TaskId:  taskId,
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvDeleteTask() (value *ActionResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error18 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error19 error
		error19, err = error18.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error19
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "DeleteTask failed: out of sequence response")
		return
	}
	result := DeleteTaskResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - TaskId
func (p *UserTaskServiceClient) GetTask(taskId int64) (r *Task, err error) {
	if err = p.sendGetTask(taskId); err != nil {
		return
	}
	return p.recvGetTask()
}

func (p *UserTaskServiceClient) sendGetTask(taskId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTask", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTaskArgs{
		TaskId: taskId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetTask() (value *Task, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error20 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error21 error
		error21, err = error20.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error21
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTask failed: out of sequence response")
		return
	}
	result := GetTaskResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - GroupId
func (p *UserTaskServiceClient) GetTasks(groupId int64) (r []*Task, err error) {
	if err = p.sendGetTasks(groupId); err != nil {
		return
	}
	return p.recvGetTasks()
}

func (p *UserTaskServiceClient) sendGetTasks(groupId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTasks", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTasksArgs{
		GroupId: groupId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetTasks() (value []*Task, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTasks failed: out of sequence response")
		return
	}
	result := GetTasksResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

func (p *UserTaskServiceClient) GetEventNames() (r []*TaskEventName, err error) {
	if err = p.sendGetEventNames(); err != nil {
		return
	}
	return p.recvGetEventNames()
}

func (p *UserTaskServiceClient) sendGetEventNames() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetEventNames", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetEventNamesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetEventNames() (value []*TaskEventName, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error24 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error25 error
		error25, err = error24.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error25
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetEventNames failed: out of sequence response")
		return
	}
	result := GetEventNamesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

func (p *UserTaskServiceClient) GetTaskTimers() (r []*TaskTimer, err error) {
	if err = p.sendGetTaskTimers(); err != nil {
		return
	}
	return p.recvGetTaskTimers()
}

func (p *UserTaskServiceClient) sendGetTaskTimers() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetTaskTimers", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTaskTimersArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetTaskTimers() (value []*TaskTimer, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetTaskTimers failed: out of sequence response")
		return
	}
	result := GetTaskTimersResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
//  - TaskId
func (p *UserTaskServiceClient) IsMissionPassed(uid int64, taskId int64) (r bool, err error) {
	if err = p.sendIsMissionPassed(uid, taskId); err != nil {
		return
	}
	return p.recvIsMissionPassed()
}

func (p *UserTaskServiceClient) sendIsMissionPassed(uid int64, taskId int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("IsMissionPassed", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IsMissionPassedArgs{
		Uid:    uid,
		TaskId: taskId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvIsMissionPassed() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "IsMissionPassed failed: out of sequence response")
		return
	}
	result := IsMissionPassedResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
func (p *UserTaskServiceClient) GetMissions(uid int64) (r []*MissionGroup, err error) {
	if err = p.sendGetMissions(uid); err != nil {
		return
	}
	return p.recvGetMissions()
}

func (p *UserTaskServiceClient) sendGetMissions(uid int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("GetMissions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetMissionsArgs{
		Uid: uid,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvGetMissions() (value []*MissionGroup, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "GetMissions failed: out of sequence response")
		return
	}
	result := GetMissionsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Uid
//  - Event
//  - N
func (p *UserTaskServiceClient) EventHandler(uid int64, event string, n int32) (r *EventResult_, err error) {
	if err = p.sendEventHandler(uid, event, n); err != nil {
		return
	}
	return p.recvEventHandler()
}

func (p *UserTaskServiceClient) sendEventHandler(uid int64, event string, n int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("EventHandler", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := EventHandlerArgs{
		Uid:   uid,
		Event: event,
		N:     n,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserTaskServiceClient) recvEventHandler() (value *EventResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "EventHandler failed: out of sequence response")
		return
	}
	result := EventHandlerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type UserTaskServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      UserTaskService
}

func (p *UserTaskServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *UserTaskServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *UserTaskServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewUserTaskServiceProcessor(handler UserTaskService) *UserTaskServiceProcessor {

	self34 := &UserTaskServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self34.processorMap["CreateGroup"] = &userTaskServiceProcessorCreateGroup{handler: handler}
	self34.processorMap["UpdateGroup"] = &userTaskServiceProcessorUpdateGroup{handler: handler}
	self34.processorMap["DeleteGroup"] = &userTaskServiceProcessorDeleteGroup{handler: handler}
	self34.processorMap["GetGroup"] = &userTaskServiceProcessorGetGroup{handler: handler}
	self34.processorMap["GetGroups"] = &userTaskServiceProcessorGetGroups{handler: handler}
	self34.processorMap["CreateTask"] = &userTaskServiceProcessorCreateTask{handler: handler}
	self34.processorMap["UpdateTask"] = &userTaskServiceProcessorUpdateTask{handler: handler}
	self34.processorMap["DeleteTask"] = &userTaskServiceProcessorDeleteTask{handler: handler}
	self34.processorMap["GetTask"] = &userTaskServiceProcessorGetTask{handler: handler}
	self34.processorMap["GetTasks"] = &userTaskServiceProcessorGetTasks{handler: handler}
	self34.processorMap["GetEventNames"] = &userTaskServiceProcessorGetEventNames{handler: handler}
	self34.processorMap["GetTaskTimers"] = &userTaskServiceProcessorGetTaskTimers{handler: handler}
	self34.processorMap["IsMissionPassed"] = &userTaskServiceProcessorIsMissionPassed{handler: handler}
	self34.processorMap["GetMissions"] = &userTaskServiceProcessorGetMissions{handler: handler}
	self34.processorMap["EventHandler"] = &userTaskServiceProcessorEventHandler{handler: handler}
	return self34
}

func (p *UserTaskServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x35 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x35.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x35

}

type userTaskServiceProcessorCreateGroup struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorCreateGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CreateGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("CreateGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CreateGroupResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.CreateGroup(args.Group); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CreateGroup: "+err2.Error())
		oprot.WriteMessageBegin("CreateGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("CreateGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorUpdateGroup struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorUpdateGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UpdateGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("UpdateGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UpdateGroupResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.UpdateGroup(args.Group); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateGroup: "+err2.Error())
		oprot.WriteMessageBegin("UpdateGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("UpdateGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorDeleteGroup struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorDeleteGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("DeleteGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteGroupResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.DeleteGroup(args.GroupId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DeleteGroup: "+err2.Error())
		oprot.WriteMessageBegin("DeleteGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("DeleteGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetGroup struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetGroup) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupResult{}
	var retval *TaskGroup
	var err2 error
	if retval, err2 = p.handler.GetGroup(args.GroupId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetGroup: "+err2.Error())
		oprot.WriteMessageBegin("GetGroup", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetGroup", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetGroups struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetGroups) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetGroupsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetGroups", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetGroupsResult{}
	var retval []*TaskGroup
	var err2 error
	if retval, err2 = p.handler.GetGroups(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetGroups: "+err2.Error())
		oprot.WriteMessageBegin("GetGroups", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetGroups", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorCreateTask struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorCreateTask) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CreateTaskArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("CreateTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CreateTaskResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.CreateTask(args.Task); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CreateTask: "+err2.Error())
		oprot.WriteMessageBegin("CreateTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("CreateTask", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorUpdateTask struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorUpdateTask) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UpdateTaskArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("UpdateTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UpdateTaskResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.UpdateTask(args.Task); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateTask: "+err2.Error())
		oprot.WriteMessageBegin("UpdateTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("UpdateTask", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorDeleteTask struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorDeleteTask) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteTaskArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("DeleteTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteTaskResult{}
	var retval *ActionResult_
	var err2 error
	if retval, err2 = p.handler.DeleteTask(args.TaskId, args.GroupId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DeleteTask: "+err2.Error())
		oprot.WriteMessageBegin("DeleteTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("DeleteTask", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetTask struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetTask) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTaskArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTaskResult{}
	var retval *Task
	var err2 error
	if retval, err2 = p.handler.GetTask(args.TaskId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTask: "+err2.Error())
		oprot.WriteMessageBegin("GetTask", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTask", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetTasks struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetTasks) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTasksArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTasks", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTasksResult{}
	var retval []*Task
	var err2 error
	if retval, err2 = p.handler.GetTasks(args.GroupId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTasks: "+err2.Error())
		oprot.WriteMessageBegin("GetTasks", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTasks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetEventNames struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetEventNames) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetEventNamesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetEventNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetEventNamesResult{}
	var retval []*TaskEventName
	var err2 error
	if retval, err2 = p.handler.GetEventNames(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetEventNames: "+err2.Error())
		oprot.WriteMessageBegin("GetEventNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetEventNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetTaskTimers struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetTaskTimers) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTaskTimersArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetTaskTimers", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTaskTimersResult{}
	var retval []*TaskTimer
	var err2 error
	if retval, err2 = p.handler.GetTaskTimers(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetTaskTimers: "+err2.Error())
		oprot.WriteMessageBegin("GetTaskTimers", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetTaskTimers", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorIsMissionPassed struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorIsMissionPassed) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsMissionPassedArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("IsMissionPassed", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsMissionPassedResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsMissionPassed(args.Uid, args.TaskId); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing IsMissionPassed: "+err2.Error())
		oprot.WriteMessageBegin("IsMissionPassed", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("IsMissionPassed", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorGetMissions struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorGetMissions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetMissionsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("GetMissions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetMissionsResult{}
	var retval []*MissionGroup
	var err2 error
	if retval, err2 = p.handler.GetMissions(args.Uid); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GetMissions: "+err2.Error())
		oprot.WriteMessageBegin("GetMissions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("GetMissions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userTaskServiceProcessorEventHandler struct {
	handler UserTaskService
}

func (p *userTaskServiceProcessorEventHandler) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := EventHandlerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("EventHandler", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := EventHandlerResult{}
	var retval *EventResult_
	var err2 error
	if retval, err2 = p.handler.EventHandler(args.Uid, args.Event, args.N); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing EventHandler: "+err2.Error())
		oprot.WriteMessageBegin("EventHandler", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("EventHandler", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type CreateGroupArgs struct {
	Group *TaskGroup `thrift:"group,1,required" json:"group"`
}

func NewCreateGroupArgs() *CreateGroupArgs {
	return &CreateGroupArgs{}
}

var CreateGroupArgs_Group_DEFAULT *TaskGroup

func (p *CreateGroupArgs) GetGroup() *TaskGroup {
	if !p.IsSetGroup() {
		return CreateGroupArgs_Group_DEFAULT
	}
	return p.Group
}
func (p *CreateGroupArgs) IsSetGroup() bool {
	return p.Group != nil
}

func (p *CreateGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateGroupArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Group = &TaskGroup{}
	if err := p.Group.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Group, err)
	}
	return nil
}

func (p *CreateGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CreateGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateGroupArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("group", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:group: %s", p, err)
	}
	if err := p.Group.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Group, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:group: %s", p, err)
	}
	return err
}

func (p *CreateGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateGroupArgs(%+v)", *p)
}

type CreateGroupResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewCreateGroupResult() *CreateGroupResult {
	return &CreateGroupResult{}
}

var CreateGroupResult_Success_DEFAULT *ActionResult_

func (p *CreateGroupResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return CreateGroupResult_Success_DEFAULT
	}
	return p.Success
}
func (p *CreateGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateGroupResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CreateGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CreateGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateGroupResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateGroupResult(%+v)", *p)
}

type UpdateGroupArgs struct {
	Group *TaskGroup `thrift:"group,1,required" json:"group"`
}

func NewUpdateGroupArgs() *UpdateGroupArgs {
	return &UpdateGroupArgs{}
}

var UpdateGroupArgs_Group_DEFAULT *TaskGroup

func (p *UpdateGroupArgs) GetGroup() *TaskGroup {
	if !p.IsSetGroup() {
		return UpdateGroupArgs_Group_DEFAULT
	}
	return p.Group
}
func (p *UpdateGroupArgs) IsSetGroup() bool {
	return p.Group != nil
}

func (p *UpdateGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateGroupArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Group = &TaskGroup{}
	if err := p.Group.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Group, err)
	}
	return nil
}

func (p *UpdateGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateGroupArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("group", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:group: %s", p, err)
	}
	if err := p.Group.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Group, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:group: %s", p, err)
	}
	return err
}

func (p *UpdateGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateGroupArgs(%+v)", *p)
}

type UpdateGroupResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewUpdateGroupResult() *UpdateGroupResult {
	return &UpdateGroupResult{}
}

var UpdateGroupResult_Success_DEFAULT *ActionResult_

func (p *UpdateGroupResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return UpdateGroupResult_Success_DEFAULT
	}
	return p.Success
}
func (p *UpdateGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateGroupResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *UpdateGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateGroupResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *UpdateGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateGroupResult(%+v)", *p)
}

type DeleteGroupArgs struct {
	GroupId int64 `thrift:"groupId,1,required" json:"groupId"`
}

func NewDeleteGroupArgs() *DeleteGroupArgs {
	return &DeleteGroupArgs{}
}

func (p *DeleteGroupArgs) GetGroupId() int64 {
	return p.GroupId
}
func (p *DeleteGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteGroupArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *DeleteGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteGroupArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:groupId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:groupId: %s", p, err)
	}
	return err
}

func (p *DeleteGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteGroupArgs(%+v)", *p)
}

type DeleteGroupResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewDeleteGroupResult() *DeleteGroupResult {
	return &DeleteGroupResult{}
}

var DeleteGroupResult_Success_DEFAULT *ActionResult_

func (p *DeleteGroupResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return DeleteGroupResult_Success_DEFAULT
	}
	return p.Success
}
func (p *DeleteGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteGroupResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *DeleteGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteGroupResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DeleteGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteGroupResult(%+v)", *p)
}

type GetGroupArgs struct {
	GroupId int64 `thrift:"groupId,1,required" json:"groupId"`
}

func NewGetGroupArgs() *GetGroupArgs {
	return &GetGroupArgs{}
}

func (p *GetGroupArgs) GetGroupId() int64 {
	return p.GroupId
}
func (p *GetGroupArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *GetGroupArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetGroup_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:groupId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:groupId: %s", p, err)
	}
	return err
}

func (p *GetGroupArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupArgs(%+v)", *p)
}

type GetGroupResult struct {
	Success *TaskGroup `thrift:"success,0" json:"success"`
}

func NewGetGroupResult() *GetGroupResult {
	return &GetGroupResult{}
}

var GetGroupResult_Success_DEFAULT *TaskGroup

func (p *GetGroupResult) GetSuccess() *TaskGroup {
	if !p.IsSetSuccess() {
		return GetGroupResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TaskGroup{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetGroupResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetGroup_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupResult(%+v)", *p)
}

type GetGroupsArgs struct {
}

func NewGetGroupsArgs() *GetGroupsArgs {
	return &GetGroupsArgs{}
}

func (p *GetGroupsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetGroups_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupsArgs(%+v)", *p)
}

type GetGroupsResult struct {
	Success []*TaskGroup `thrift:"success,0" json:"success"`
}

func NewGetGroupsResult() *GetGroupsResult {
	return &GetGroupsResult{}
}

var GetGroupsResult_Success_DEFAULT []*TaskGroup

func (p *GetGroupsResult) GetSuccess() []*TaskGroup {
	return p.Success
}
func (p *GetGroupsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetGroupsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetGroupsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TaskGroup, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem36 := &TaskGroup{}
		if err := _elem36.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem36, err)
		}
		p.Success = append(p.Success, _elem36)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetGroupsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetGroups_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetGroupsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetGroupsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetGroupsResult(%+v)", *p)
}

type CreateTaskArgs struct {
	Task *Task `thrift:"task,1,required" json:"task"`
}

func NewCreateTaskArgs() *CreateTaskArgs {
	return &CreateTaskArgs{}
}

var CreateTaskArgs_Task_DEFAULT *Task

func (p *CreateTaskArgs) GetTask() *Task {
	if !p.IsSetTask() {
		return CreateTaskArgs_Task_DEFAULT
	}
	return p.Task
}
func (p *CreateTaskArgs) IsSetTask() bool {
	return p.Task != nil
}

func (p *CreateTaskArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTaskArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Task = &Task{}
	if err := p.Task.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Task, err)
	}
	return nil
}

func (p *CreateTaskArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CreateTask_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTaskArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("task", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:task: %s", p, err)
	}
	if err := p.Task.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Task, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:task: %s", p, err)
	}
	return err
}

func (p *CreateTaskArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTaskArgs(%+v)", *p)
}

type CreateTaskResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewCreateTaskResult() *CreateTaskResult {
	return &CreateTaskResult{}
}

var CreateTaskResult_Success_DEFAULT *ActionResult_

func (p *CreateTaskResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return CreateTaskResult_Success_DEFAULT
	}
	return p.Success
}
func (p *CreateTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateTaskResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTaskResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CreateTaskResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CreateTask_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTaskResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CreateTaskResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTaskResult(%+v)", *p)
}

type UpdateTaskArgs struct {
	Task *Task `thrift:"task,1,required" json:"task"`
}

func NewUpdateTaskArgs() *UpdateTaskArgs {
	return &UpdateTaskArgs{}
}

var UpdateTaskArgs_Task_DEFAULT *Task

func (p *UpdateTaskArgs) GetTask() *Task {
	if !p.IsSetTask() {
		return UpdateTaskArgs_Task_DEFAULT
	}
	return p.Task
}
func (p *UpdateTaskArgs) IsSetTask() bool {
	return p.Task != nil
}

func (p *UpdateTaskArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateTaskArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Task = &Task{}
	if err := p.Task.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Task, err)
	}
	return nil
}

func (p *UpdateTaskArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateTask_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateTaskArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("task", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:task: %s", p, err)
	}
	if err := p.Task.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Task, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:task: %s", p, err)
	}
	return err
}

func (p *UpdateTaskArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateTaskArgs(%+v)", *p)
}

type UpdateTaskResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewUpdateTaskResult() *UpdateTaskResult {
	return &UpdateTaskResult{}
}

var UpdateTaskResult_Success_DEFAULT *ActionResult_

func (p *UpdateTaskResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return UpdateTaskResult_Success_DEFAULT
	}
	return p.Success
}
func (p *UpdateTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateTaskResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateTaskResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *UpdateTaskResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UpdateTask_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateTaskResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *UpdateTaskResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateTaskResult(%+v)", *p)
}

type DeleteTaskArgs struct {
	TaskId  int64 `thrift:"taskId,1,required" json:"taskId"`
	GroupId int64 `thrift:"groupId,2,required" json:"groupId"`
}

func NewDeleteTaskArgs() *DeleteTaskArgs {
	return &DeleteTaskArgs{}
}

func (p *DeleteTaskArgs) GetTaskId() int64 {
	return p.TaskId
}

func (p *DeleteTaskArgs) GetGroupId() int64 {
	return p.GroupId
}
func (p *DeleteTaskArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTaskArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TaskId = v
	}
	return nil
}

func (p *DeleteTaskArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *DeleteTaskArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteTask_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTaskArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("taskId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:taskId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TaskId)); err != nil {
		return fmt.Errorf("%T.taskId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:taskId: %s", p, err)
	}
	return err
}

func (p *DeleteTaskArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:groupId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:groupId: %s", p, err)
	}
	return err
}

func (p *DeleteTaskArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTaskArgs(%+v)", *p)
}

type DeleteTaskResult struct {
	Success *ActionResult_ `thrift:"success,0" json:"success"`
}

func NewDeleteTaskResult() *DeleteTaskResult {
	return &DeleteTaskResult{}
}

var DeleteTaskResult_Success_DEFAULT *ActionResult_

func (p *DeleteTaskResult) GetSuccess() *ActionResult_ {
	if !p.IsSetSuccess() {
		return DeleteTaskResult_Success_DEFAULT
	}
	return p.Success
}
func (p *DeleteTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteTaskResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTaskResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ActionResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *DeleteTaskResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("DeleteTask_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTaskResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTaskResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTaskResult(%+v)", *p)
}

type GetTaskArgs struct {
	TaskId int64 `thrift:"taskId,1,required" json:"taskId"`
}

func NewGetTaskArgs() *GetTaskArgs {
	return &GetTaskArgs{}
}

func (p *GetTaskArgs) GetTaskId() int64 {
	return p.TaskId
}
func (p *GetTaskArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTaskArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.TaskId = v
	}
	return nil
}

func (p *GetTaskArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTask_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTaskArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("taskId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:taskId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TaskId)); err != nil {
		return fmt.Errorf("%T.taskId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:taskId: %s", p, err)
	}
	return err
}

func (p *GetTaskArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTaskArgs(%+v)", *p)
}

type GetTaskResult struct {
	Success *Task `thrift:"success,0" json:"success"`
}

func NewGetTaskResult() *GetTaskResult {
	return &GetTaskResult{}
}

var GetTaskResult_Success_DEFAULT *Task

func (p *GetTaskResult) GetSuccess() *Task {
	if !p.IsSetSuccess() {
		return GetTaskResult_Success_DEFAULT
	}
	return p.Success
}
func (p *GetTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTaskResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTaskResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Task{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTaskResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTask_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTaskResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTaskResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTaskResult(%+v)", *p)
}

type GetTasksArgs struct {
	GroupId int64 `thrift:"groupId,1,required" json:"groupId"`
}

func NewGetTasksArgs() *GetTasksArgs {
	return &GetTasksArgs{}
}

func (p *GetTasksArgs) GetGroupId() int64 {
	return p.GroupId
}
func (p *GetTasksArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTasksArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.GroupId = v
	}
	return nil
}

func (p *GetTasksArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTasks_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTasksArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("groupId", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:groupId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.GroupId)); err != nil {
		return fmt.Errorf("%T.groupId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:groupId: %s", p, err)
	}
	return err
}

func (p *GetTasksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTasksArgs(%+v)", *p)
}

type GetTasksResult struct {
	Success []*Task `thrift:"success,0" json:"success"`
}

func NewGetTasksResult() *GetTasksResult {
	return &GetTasksResult{}
}

var GetTasksResult_Success_DEFAULT []*Task

func (p *GetTasksResult) GetSuccess() []*Task {
	return p.Success
}
func (p *GetTasksResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTasksResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTasksResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Task, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem37 := &Task{}
		if err := _elem37.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem37, err)
		}
		p.Success = append(p.Success, _elem37)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTasksResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTasks_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTasksResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTasksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTasksResult(%+v)", *p)
}

type GetEventNamesArgs struct {
}

func NewGetEventNamesArgs() *GetEventNamesArgs {
	return &GetEventNamesArgs{}
}

func (p *GetEventNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetEventNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetEventNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetEventNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetEventNamesArgs(%+v)", *p)
}

type GetEventNamesResult struct {
	Success []*TaskEventName `thrift:"success,0" json:"success"`
}

func NewGetEventNamesResult() *GetEventNamesResult {
	return &GetEventNamesResult{}
}

var GetEventNamesResult_Success_DEFAULT []*TaskEventName

func (p *GetEventNamesResult) GetSuccess() []*TaskEventName {
	return p.Success
}
func (p *GetEventNamesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetEventNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetEventNamesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TaskEventName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem38 := &TaskEventName{}
		if err := _elem38.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem38, err)
		}
		p.Success = append(p.Success, _elem38)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetEventNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetEventNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetEventNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetEventNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetEventNamesResult(%+v)", *p)
}

type GetTaskTimersArgs struct {
}

func NewGetTaskTimersArgs() *GetTaskTimersArgs {
	return &GetTaskTimersArgs{}
}

func (p *GetTaskTimersArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTaskTimersArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTaskTimers_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTaskTimersArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTaskTimersArgs(%+v)", *p)
}

type GetTaskTimersResult struct {
	Success []*TaskTimer `thrift:"success,0" json:"success"`
}

func NewGetTaskTimersResult() *GetTaskTimersResult {
	return &GetTaskTimersResult{}
}

var GetTaskTimersResult_Success_DEFAULT []*TaskTimer

func (p *GetTaskTimersResult) GetSuccess() []*TaskTimer {
	return p.Success
}
func (p *GetTaskTimersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTaskTimersResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTaskTimersResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TaskTimer, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem39 := &TaskTimer{}
		if err := _elem39.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem39, err)
		}
		p.Success = append(p.Success, _elem39)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTaskTimersResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetTaskTimers_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTaskTimersResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTaskTimersResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTaskTimersResult(%+v)", *p)
}

type IsMissionPassedArgs struct {
	Uid    int64 `thrift:"uid,1,required" json:"uid"`
	TaskId int64 `thrift:"taskId,2,required" json:"taskId"`
}

func NewIsMissionPassedArgs() *IsMissionPassedArgs {
	return &IsMissionPassedArgs{}
}

func (p *IsMissionPassedArgs) GetUid() int64 {
	return p.Uid
}

func (p *IsMissionPassedArgs) GetTaskId() int64 {
	return p.TaskId
}
func (p *IsMissionPassedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsMissionPassedArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *IsMissionPassedArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.TaskId = v
	}
	return nil
}

func (p *IsMissionPassedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IsMissionPassed_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsMissionPassedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *IsMissionPassedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("taskId", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:taskId: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.TaskId)); err != nil {
		return fmt.Errorf("%T.taskId (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:taskId: %s", p, err)
	}
	return err
}

func (p *IsMissionPassedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsMissionPassedArgs(%+v)", *p)
}

type IsMissionPassedResult struct {
	Success *bool `thrift:"success,0" json:"success"`
}

func NewIsMissionPassedResult() *IsMissionPassedResult {
	return &IsMissionPassedResult{}
}

var IsMissionPassedResult_Success_DEFAULT bool

func (p *IsMissionPassedResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsMissionPassedResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *IsMissionPassedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsMissionPassedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsMissionPassedResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsMissionPassedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IsMissionPassed_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsMissionPassedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsMissionPassedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsMissionPassedResult(%+v)", *p)
}

type GetMissionsArgs struct {
	Uid int64 `thrift:"uid,1,required" json:"uid"`
}

func NewGetMissionsArgs() *GetMissionsArgs {
	return &GetMissionsArgs{}
}

func (p *GetMissionsArgs) GetUid() int64 {
	return p.Uid
}
func (p *GetMissionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMissionsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *GetMissionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetMissions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMissionsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *GetMissionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMissionsArgs(%+v)", *p)
}

type GetMissionsResult struct {
	Success []*MissionGroup `thrift:"success,0" json:"success"`
}

func NewGetMissionsResult() *GetMissionsResult {
	return &GetMissionsResult{}
}

var GetMissionsResult_Success_DEFAULT []*MissionGroup

func (p *GetMissionsResult) GetSuccess() []*MissionGroup {
	return p.Success
}
func (p *GetMissionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMissionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMissionsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*MissionGroup, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem40 := &MissionGroup{}
		if err := _elem40.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem40, err)
		}
		p.Success = append(p.Success, _elem40)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMissionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("GetMissions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMissionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetMissionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMissionsResult(%+v)", *p)
}

type EventHandlerArgs struct {
	Uid   int64  `thrift:"uid,1,required" json:"uid"`
	Event string `thrift:"event,2,required" json:"event"`
	N     int32  `thrift:"n,3,required" json:"n"`
}

func NewEventHandlerArgs() *EventHandlerArgs {
	return &EventHandlerArgs{}
}

func (p *EventHandlerArgs) GetUid() int64 {
	return p.Uid
}

func (p *EventHandlerArgs) GetEvent() string {
	return p.Event
}

func (p *EventHandlerArgs) GetN() int32 {
	return p.N
}
func (p *EventHandlerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EventHandlerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Uid = v
	}
	return nil
}

func (p *EventHandlerArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Event = v
	}
	return nil
}

func (p *EventHandlerArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.N = v
	}
	return nil
}

func (p *EventHandlerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EventHandler_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EventHandlerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uid", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:uid: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Uid)); err != nil {
		return fmt.Errorf("%T.uid (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:uid: %s", p, err)
	}
	return err
}

func (p *EventHandlerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("event", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:event: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Event)); err != nil {
		return fmt.Errorf("%T.event (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:event: %s", p, err)
	}
	return err
}

func (p *EventHandlerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("n", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:n: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.N)); err != nil {
		return fmt.Errorf("%T.n (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:n: %s", p, err)
	}
	return err
}

func (p *EventHandlerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EventHandlerArgs(%+v)", *p)
}

type EventHandlerResult struct {
	Success *EventResult_ `thrift:"success,0" json:"success"`
}

func NewEventHandlerResult() *EventHandlerResult {
	return &EventHandlerResult{}
}

var EventHandlerResult_Success_DEFAULT *EventResult_

func (p *EventHandlerResult) GetSuccess() *EventResult_ {
	if !p.IsSetSuccess() {
		return EventHandlerResult_Success_DEFAULT
	}
	return p.Success
}
func (p *EventHandlerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EventHandlerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EventHandlerResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &EventResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *EventHandlerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EventHandler_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EventHandlerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *EventHandlerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EventHandlerResult(%+v)", *p)
}
